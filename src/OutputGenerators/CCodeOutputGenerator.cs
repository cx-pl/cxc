using Antlr4.Runtime.Atn;
using CxCompiler.Model;
using CxCompiler.Model.Common;
using CxCompiler.Model.Project;
using CxCompiler.Model.Types;
using CxCompiler.Model.Types.BuiltInTypes;
using System;
using System.Collections;
using System.Linq;

namespace CxCompiler.OutputGenerators;

public static class CCodeOutputGenerator
{
    public static void GenerateOutput(CxProject project, string filePath)
    {
        if (project == null)
        {
            throw new InternalCompilerException("Project is null");
        }

        WriteProjectHeaderFile(project, Path.Combine(Path.GetDirectoryName(filePath)!, $"{project.Name}.h"));
        WriteProjectSourceFile(project, Path.Combine(Path.GetDirectoryName(filePath)!, $"{project.Name}.c"));
    }

    private static void WriteProjectHeaderFile(CxProject project, string outputFilePath)
    {
        using var fileWriter = new StreamWriter(outputFilePath);
        var writer = new IndentingWriter(fileWriter);

        writer.WriteLine($"// This is an autogenerated C header file from project {project.Name}");
        writer.WriteLine();

        string headerGuardName = project.Name.ToUpperInvariant().Replace('.', '_');
        writer.WriteLine($"#ifndef _{headerGuardName}_H_");
        writer.WriteLine($"#define _{headerGuardName}_H_");
        writer.WriteLine();
        writer.WriteLine($"#include <cx.h>");
        writer.WriteLine();

        var cxcoreTypeOrder = new Dictionary<string, int>
        {
            { "Object", -1000 },
            { "Nullable", -900 },
            { "TypeInfo", -800 },
            { "VersionInfo", -700 }
        }; // TODO: Remove this hack for cxcore

        var declarations = GetDeclarations(project)
            .Order(Comparer<DeclarationBase>.Create((x, y) =>
            {
                if (x is ClassDeclaration xClassDeclaration && y is ClassDeclaration yClassDeclaration)
                {
                    if (project.Name == "cxcore") // TODO: Remove this hack for cxcore
                    {
                        if (cxcoreTypeOrder.ContainsKey(x.Name) && !cxcoreTypeOrder.ContainsKey(y.Name))
                        {
                            return -1;
                        }
                        else if (!cxcoreTypeOrder.ContainsKey(x.Name) && cxcoreTypeOrder.ContainsKey(y.Name))
                        {
                            return 1;
                        }
                        else if (cxcoreTypeOrder.ContainsKey(x.Name) && cxcoreTypeOrder.ContainsKey(y.Name))
                        {
                            return cxcoreTypeOrder[x.Name].CompareTo(cxcoreTypeOrder[y.Name]);
                        }
                    }

                    if (xClassDeclaration.BaseTypes.Any(t => t == yClassDeclaration.FullName))
                    {
                        return -1;
                    }
                    else if (yClassDeclaration.BaseTypes.Any(t => t == xClassDeclaration.FullName))
                    {
                        return 1;
                    }
                    else
                    {
                        return QualifiedIdentifier.Compare(xClassDeclaration.FullName, yClassDeclaration.FullName);
                    }
                }
                else if (x is FunctionDeclaration xFunctionDeclaration && y is FunctionDeclaration yFunctionDeclaration)
                {
                    return QualifiedIdentifier.Compare(xFunctionDeclaration.FullName, yFunctionDeclaration.FullName);
                }
                else if (x is ClassDeclaration)
                {
                    return -1; // Classes before functions
                }
                else
                {
                    return 1; // Functions after classes
                }
            }))
            .ToArray();

        writer.WriteLine("//");
        writer.WriteLine("// Forward type declarations");
        writer.WriteLine("//");
        writer.WriteLine();
        WriteTypesForwardDeclarations(writer, declarations, project.Name);
        writer.WriteLine();

        writer.WriteLine("//");
        writer.WriteLine("// Type declarations");
        writer.WriteLine("//");
        writer.WriteLine();
        WriteTypesDeclarations(writer, declarations, project.Name);
        writer.WriteLine();

        writer.WriteLine("//");
        writer.WriteLine("// Function declarations");
        writer.WriteLine("//");
        writer.WriteLine();
        WriteFunctionsForwardDeclarations(writer, declarations, project.Name);
        writer.WriteLine();

        writer.WriteLine();
        writer.WriteLine($"#endif // _{headerGuardName}_H_");

        fileWriter.Flush();
        fileWriter.Close();
    }

    private static IEnumerable<DeclarationBase> GetDeclarations(CxProject project)
    {
        foreach (var compilationContext in project.CompilationContexts)
        {
            foreach (var declaration in compilationContext.DeclarationScope.Declarations)
            {
                declaration.Namespace = compilationContext.DeclarationScope.Namespace;

                if (declaration is ClassDeclaration classDeclaration)
                {
                    yield return classDeclaration;
                }
                else if (declaration is FunctionDeclaration functionDeclaration)
                {
                    yield return functionDeclaration;
                }
            }
        }
    }

    private static void WriteTypesForwardDeclarations(
        IndentingWriter writer,
        IReadOnlyCollection<DeclarationBase> declarations,
        string moduleName)
    {
        foreach (var declaration in declarations)
        {
            if (declaration is ClassDeclaration classDeclaration)
            {
                writer.WriteLine($"{classDeclaration.ToCIdentifier(moduleName)};");

                var memberDeclarations = classDeclaration.MemberDeclarations.Declarations
                    .Where(x => x is ClassDeclaration)
                    .ToArray();
                if (memberDeclarations.Length != 0)
                {
                    WriteTypesForwardDeclarations(writer, memberDeclarations, moduleName);
                }
            }
        }
    }

    private static void WriteTypesDeclarations(
        IndentingWriter writer,
        IReadOnlyCollection<DeclarationBase> declarations,
        string moduleName)
    {
        foreach (var declaration in declarations)
        {
            if (declaration is ClassDeclaration classDeclaration)
            {
                if (classDeclaration.ClassType == ClassType.Class && classDeclaration.IsStatic)
                {
                    writer.WriteLine($"CX_STATIC_TYPE_DEF({classDeclaration.ToCIdentifier(moduleName, false)});");
                }
                else
                {
                    writer.WriteLine($"CX_TYPE_DEF({classDeclaration.ToCIdentifier(moduleName, false)}) {{");

                    writer.IncreaseIndent();

                    if (moduleName == "cxcore" && classDeclaration.Name == "Object")
                    {
                        writer.WriteLine("void* __vtable;");
                    }
                    else if (classDeclaration.ClassType == ClassType.Interface)
                    {
                        writer.WriteLine("void* __vtable;");
                        writer.WriteLine("void* __root;");
                    }
                    else if (classDeclaration.ClassType == ClassType.Class)
                    {
                        // TODO: Get class base type from classDeclaration.BaseTypes
                        writer.WriteLine("struct CX_ID_3(cxcore, System, Object) __base;");
                    }

                    var fieldMemberDeclarations = classDeclaration.MemberDeclarations.Declarations
                        .OfType<FieldDeclaration>()
                        .ToArray();
                    if (!fieldMemberDeclarations.Any() &&
                        classDeclaration.ClassType == ClassType.Struct)
                    {
                        writer.WriteLine("cx_byte __dummy;");
                    }
                    else
                    {
                        foreach (var fieldDeclaration in fieldMemberDeclarations)
                        {
                            writer.WriteLine($"{fieldDeclaration.Type.ToCIdentifier()} {fieldDeclaration.Name};");
                            //if (fieldDeclaration.InitialValue != null)
                            //{
                            //    writer.Write($" = {fieldDeclaration.InitialValue.ToCIdentifier()}");
                            //}
                        }
                    }

                    writer.DecreaseIndent();
                    writer.WriteLine("};");

                    var classMemberDeclarations = classDeclaration.MemberDeclarations.Declarations
                        .OfType<ClassDeclaration>()
                        .ToArray();
                    if (classMemberDeclarations.Length != 0)
                    {
                        WriteTypesDeclarations(writer, classMemberDeclarations, moduleName);
                    }
                }
            }
        }
    }

    private static void WriteFunctionsForwardDeclarations(
        IndentingWriter writer,
        IReadOnlyCollection<DeclarationBase> declarations,
        string moduleName)
    {
        foreach (var declaration in declarations)
        {
            switch (declaration)
            {
                case ClassDeclaration classDeclaration:
                    var memberDeclarations = classDeclaration.MemberDeclarations.Declarations.ToArray();
                    if (memberDeclarations.Length != 0)
                    {
                        WriteFunctionsForwardDeclarations(writer, memberDeclarations, moduleName);
                    }

                    break;

                case FunctionDeclaration functionDeclaration:
                    bool exportable =
                        (
                            functionDeclaration.ParentClassDeclaration?.ClassType == ClassType.Interface
                        ) ||
                        (
                            functionDeclaration.ParentClassDeclaration == null &&
                            functionDeclaration.MemberModifiers.Contains(MemberModifier.Public)
                        ) ||
                        (
                            functionDeclaration.ParentClassDeclaration?.ClassType == ClassType.Struct &&
                            functionDeclaration.MemberModifiers.Contains(MemberModifier.Public) &&
                            functionDeclaration.ParentClassDeclaration?.Visibility == Visibility.Public
                        ) ||
                        (
                            functionDeclaration.ParentClassDeclaration?.ClassType == ClassType.Class &&
                            functionDeclaration.MemberModifiers.Contains(MemberModifier.Public) &&
                            functionDeclaration.ParentClassDeclaration?.Visibility == Visibility.Public
                        ); // TODO: Traverse up all class hierarchy
                    writer.WriteIndent();
                    writer.Write($"extern {(exportable ? "CX_EXPORT " : "")}{functionDeclaration.ToCIdentifier(moduleName)}(");
                    writer.IncreaseIndent();

                    bool isFirstParameter = true;
                    if (!functionDeclaration.IsStatic)
                    {
                        writer.WriteNewLine();
                        writer.WriteIndent();
                        writer.Write($"{functionDeclaration.ParentClassDeclaration!.ToCIdentifier(moduleName)}* __this");
                        writer.WriteNewLine();
                        isFirstParameter = false;
                    }

                    if (functionDeclaration.Parameters.Count > 0)
                    {
                        if (!isFirstParameter)
                        {
                            writer.Write(",");
                        }

                        writer.WriteLine();

                        for (int i = 0; i < functionDeclaration.Parameters.Count; i++)
                        {
                            FunctionParameter? parameter = functionDeclaration.Parameters[i];
                            writer.WriteIndent();
                            writer.Write($"{parameter.Type.ToCIdentifier()} {parameter.Name}");

                            //if (parameter.DefaultValue != null)
                            //{
                            //    writer.Write($" = {parameter.DefaultValue.ToCIdentifier()}");
                            //}

                            if (i != functionDeclaration.Parameters.Count - 1)
                            {
                                writer.Write(",");
                            }

                            writer.WriteNewLine();
                        }

                    }

                    writer.DecreaseIndent();
                    writer.WriteLine(");");
                    break;
            }
        }
    }

    private static void WriteProjectSourceFile(CxProject project, string outputFilePath)
    {
        using var fileWriter = new StreamWriter(outputFilePath);
        var writer = new IndentingWriter(fileWriter);

        writer.WriteLine($"// This is an autogenerated C source file project {project.Name}");
        writer.WriteLine();
        writer.WriteLine($"#include \"{project.Name}.h\"");
        //writer.WriteLine();

        // TODO

        fileWriter.Flush();
        fileWriter.Close();
    }

    private static string ToCIdentifier(this ClassDeclaration classDeclaration, string moduleName, bool includeStruct = true)
    {
        var fullName = new QualifiedIdentifier(moduleName, classDeclaration.FullName);
        return $"{(includeStruct ? "struct " : "")}{fullName.ToCIdentifier()}";
    }

    private static string ToCIdentifier(this FunctionDeclaration functionDeclaration, string moduleName)
    {
        var fullName = new QualifiedIdentifier(moduleName, functionDeclaration.FullName);
        return $"{functionDeclaration.ReturnType.ToCIdentifier()} {fullName.ToCIdentifier()}";
    }

    private static string ToCIdentifier(this TypeBase typeBase)
    {
        return typeBase switch
        {
            BoolType => "cx_bool",
            CharType => "cx_char",

            SByteType => "cx_sbyte",
            ShortType => "cx_short",
            IntType => "cx_int",
            LongType => "cx_long",

            ByteType => "cx_byte",
            UShortType => "cx_ushort",
            UIntType => "cx_uint",
            ULongType => "cx_ulong",

            FloatType => "cx_float",
            DoubleType => "cx_double",

            ObjectType => "struct CX_ID_3(cxcore, System, Object)*",
            StringType => "struct CX_ID_3(cxcore, System, String)*",
            PtrType => "cx_ptr",

            FunctionType => throw new NotImplementedException(), // TODO
            VoidType => "void",

            ArrayType => $"struct CX_ID_3(cxcore, System, Array)*",
            NullableType => $"struct CX_ID_3(cxcore, System, Nullable)",

            NamedType namedType when namedType.ClassType == ClassType.Struct => $"struct {namedType.ResolvedTypeFullName.ToCIdentifier()}",
            NamedType namedType when namedType.ClassType == ClassType.Class => $"struct {namedType.ResolvedTypeFullName.ToCIdentifier()}*",

            _ => "_unknowntype_" // TODO: throw below exception for unsupported types
            //_ => throw new InternalCompilerException($"Unsupported type: {typeBase.GetType().Name}"),
        };
    }

    private static string ToCIdentifier(this QualifiedIdentifier qualifiedIdentifier)
    {
        if (qualifiedIdentifier.IsEmpty)
        {
            throw new InternalCompilerException("QualifiedIdentifier cannot be empty");
        }

        if (qualifiedIdentifier.Parts.Length == 1)
        {
            return qualifiedIdentifier.Parts[0];
        }

        return $"CX_ID_{qualifiedIdentifier.Parts.Length}({string.Join(", ", qualifiedIdentifier.Parts)})";
    }
}
